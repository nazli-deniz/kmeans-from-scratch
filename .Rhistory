# ==============================
k_chosen <- 3
set.seed(42)
km_builtin <- kmeans(scaled_data, centers = k_chosen, nstart = 25)
builtin_clusters <- km_builtin$cluster
# ==============================
# 3. Scratch K-means (K-means++ initialization)
# ==============================
history_scratch <- kmeans_iterations(scaled_data, k = k_chosen, max_iter = 100, use_kmeanspp = TRUE)
final_iter <- tail(history_scratch, 1)[[1]]  # last iteration
scratch_clusters <- final_iter$clusters
scratch_centroids <- final_iter$centroids
# ==============================
# 4. Cluster-to-species mapping (Hungarian algorithm)
# ==============================
map_clusters_to_species <- function(clusters, species) {
clusters <- as.numeric(clusters)
species_num <- as.numeric(factor(species))
k <- length(unique(clusters))
# Contingency table
tab <- table(clusters, species_num)
# Optimal assignment
assignment <- solve_LSAP(tab, maximum = TRUE)
# Remap clusters
new_clusters <- clusters
for (i in 1:k) {
new_clusters[clusters == i] <- assignment[i]
}
# Convert back to factor with species names
factor(new_clusters, labels = levels(factor(species)))
}
scratch_matched <- map_clusters_to_species(scratch_clusters, iris$Species)
builtin_matched <- map_clusters_to_species(builtin_clusters, iris$Species)
# ==============================
# 5. PCA for visualization
# ==============================
pca_res <- prcomp(scaled_data, center = TRUE, scale. = TRUE)
pca_data <- data.frame(pca_res$x[,1:2],
ScratchCluster = factor(scratch_clusters),
BuiltinCluster = factor(builtin_clusters),
ScratchMatched = scratch_matched,
BuiltinMatched = builtin_matched,
Species = iris$Species)
# ==============================
# 6. PCA plots
# ==============================
# Scratch K-means
p_scratch <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Scratch K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Built-in K-means
p_builtin <- ggplot(pca_data, aes(x = PC1, y = PC2, color = BuiltinMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Built-in K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Scratch K-means centroids overlay
centroids_pca <- predict(pca_res, newdata = scratch_centroids)
centroids_df <- data.frame(centroids_pca[,1:2])
p_centroids <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched)) +
geom_point(alpha = 0.4) +
geom_point(data = centroids_df, aes(x = PC1, y = PC2),
shape = 8, color = "black", size = 4) +
labs(title = "Scratch K-Means Centroids (PCA)") +
theme_minimal()
# ==============================
# 7. Confusion tables
# ==============================
cat("Scratch K-means vs true species:\n")
print(table(Predicted = scratch_matched, Actual = iris$Species))
cat("\nBuilt-in K-means vs true species:\n")
print(table(Predicted = builtin_matched, Actual = iris$Species))
# ==============================
# 8. Display plots together
# ==============================
grid.arrange(elbow_plot, p_scratch, p_builtin, p_centroids, ncol = 2)
# ==============================
# K-MEANS COMPARISON SCRIPT
# ==============================
# Load scratch implementation
source("kmeans_helpers.R")
source("kmeans_main.R")
# Load required libraries
library(ggplot2)
library(gridExtra) # for arranging multiple plots
library(clue)      # for Hungarian algorithm
# ==============================
# Prepare data
# ==============================
data(iris)
X <- as.matrix(iris[, 1:4])
colnames(X) <- colnames(iris[, 1:4])
scaled_data <- scale(X)
colnames(scaled_data) <- colnames(X)
# ==============================
# 1. Elbow method (built-in kmeans)
# ==============================
set.seed(42)
wss <- sapply(1:10, function(k){
kmeans(scaled_data, k, nstart = 25)$tot.withinss
})
elbow_plot <- ggplot(data.frame(k = 1:10, WSS = wss), aes(x = k, y = WSS)) +
geom_point() + geom_line() +
labs(title = "Elbow Method for Iris (Built-in K-means)",
x = "Number of clusters k",
y = "Total Within-Cluster Sum of Squares") +
theme_minimal()
# ==============================
# 2. Built-in K-means (k=3)
# ==============================
k_chosen <- 3
set.seed(42)
km_builtin <- kmeans(scaled_data, centers = k_chosen, nstart = 25)
builtin_clusters <- km_builtin$cluster
# ==============================
# 3. Scratch K-means (K-means++ initialization)
# ==============================
history_scratch <- kmeans_iterations(scaled_data, k = k_chosen, max_iter = 100, use_kmeanspp = TRUE)
final_iter <- tail(history_scratch, 1)[[1]]  # last iteration
scratch_clusters <- final_iter$clusters
scratch_centroids <- final_iter$centroids
# ==============================
# 4. Cluster-to-species mapping (Hungarian algorithm)
# ==============================
map_clusters_to_species <- function(clusters, species) {
clusters <- as.numeric(clusters)
species_num <- as.numeric(factor(species))
k <- length(unique(clusters))
# Contingency table
tab <- table(clusters, species_num)
# Optimal assignment
assignment <- solve_LSAP(tab, maximum = TRUE)
# Remap clusters
new_clusters <- clusters
for (i in 1:k) {
new_clusters[clusters == i] <- assignment[i]
}
# Convert back to factor with species names
factor(new_clusters, labels = levels(factor(species)))
}
scratch_matched <- map_clusters_to_species(scratch_clusters, iris$Species)
builtin_matched <- map_clusters_to_species(builtin_clusters, iris$Species)
# ==============================
# 5. PCA for visualization
# ==============================
pca_res <- prcomp(scaled_data, center = TRUE, scale. = TRUE)
pca_data <- data.frame(pca_res$x[,1:2],
ScratchCluster = factor(scratch_clusters),
BuiltinCluster = factor(builtin_clusters),
ScratchMatched = scratch_matched,
BuiltinMatched = builtin_matched,
Species = iris$Species)
# ==============================
# 6. PCA plots
# ==============================
# Scratch K-means
p_scratch <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Scratch K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Built-in K-means
p_builtin <- ggplot(pca_data, aes(x = PC1, y = PC2, color = BuiltinMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Built-in K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Scratch K-means centroids overlay
centroids_pca <- predict(pca_res, newdata = scratch_centroids)
centroids_df <- data.frame(centroids_pca[,1:2])
p_centroids <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched)) +
geom_point(alpha = 0.4) +
geom_point(data = centroids_df, aes(x = PC1, y = PC2),
shape = 8, color = "black", size = 4) +
labs(title = "Scratch K-Means Centroids (PCA)") +
theme_minimal()
# ==============================
# 7. Confusion tables
# ==============================
cat("Scratch K-means vs true species:\n")
print(table(Predicted = scratch_matched, Actual = iris$Species))
cat("\nBuilt-in K-means vs true species:\n")
print(table(Predicted = builtin_matched, Actual = iris$Species))
# ==============================
# 8. Display plots together
# ==============================
grid.arrange(elbow_plot, p_scratch, p_builtin, p_centroids, ncol = 2)
# ==============================
# K-MEANS COMPARISON SCRIPT
# ==============================
# Load scratch implementation
source("kmeans_helpers.R")
source("kmeans_main.R")
# Load required libraries
library(ggplot2)
library(gridExtra) # for arranging multiple plots
library(clue)      # for Hungarian algorithm
# ==============================
# Prepare data
# ==============================
data(iris)
X <- as.matrix(iris[, 1:4])
colnames(X) <- colnames(iris[, 1:4])
scaled_data <- scale(X)
colnames(scaled_data) <- colnames(X)
# ==============================
# 1. Elbow method (built-in kmeans)
# ==============================
set.seed(42)
wss <- sapply(1:10, function(k){
kmeans(scaled_data, k, nstart = 25)$tot.withinss
})
elbow_plot <- ggplot(data.frame(k = 1:10, WSS = wss), aes(x = k, y = WSS)) +
geom_point() + geom_line() +
labs(title = "Elbow Method for Iris (Built-in K-means)",
x = "Number of clusters k",
y = "Total Within-Cluster Sum of Squares") +
theme_minimal()
# ==============================
# 2. Built-in K-means (k=3)
# ==============================
k_chosen <- 3
set.seed(42)
km_builtin <- kmeans(scaled_data, centers = k_chosen, nstart = 25)
builtin_clusters <- km_builtin$cluster
# ==============================
# 3. Scratch K-means (K-means++ initialization)
# ==============================
history_scratch <- kmeans_iterations(scaled_data, k = k_chosen, max_iter = 100, use_kmeanspp = TRUE)
final_iter <- tail(history_scratch, 1)[[1]]  # last iteration
scratch_clusters <- final_iter$clusters
scratch_centroids <- final_iter$centroids
# ==============================
# 4. Cluster-to-species mapping (Hungarian algorithm)
# ==============================
map_clusters_to_species <- function(clusters, species) {
clusters <- as.numeric(clusters)
species_num <- as.numeric(factor(species))
k <- length(unique(clusters))
# Contingency table
tab <- table(clusters, species_num)
# Optimal assignment
assignment <- solve_LSAP(tab, maximum = TRUE)
# Remap clusters
new_clusters <- clusters
for (i in 1:k) {
new_clusters[clusters == i] <- assignment[i]
}
# Convert back to factor with species names
factor(new_clusters, labels = levels(factor(species)))
}
scratch_matched <- map_clusters_to_species(scratch_clusters, iris$Species)
builtin_matched <- map_clusters_to_species(builtin_clusters, iris$Species)
# ==============================
# 5. PCA for visualization
# ==============================
pca_res <- prcomp(scaled_data, center = TRUE, scale. = TRUE)
pca_data <- data.frame(pca_res$x[,1:2],
ScratchCluster = factor(scratch_clusters),
BuiltinCluster = factor(builtin_clusters),
ScratchMatched = scratch_matched,
BuiltinMatched = builtin_matched,
Species = iris$Species)
# ==============================
# 6. PCA plots
# ==============================
# Scratch K-means
p_scratch <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Scratch K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Built-in K-means
p_builtin <- ggplot(pca_data, aes(x = PC1, y = PC2, color = BuiltinMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Built-in K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Scratch K-means centroids overlay
centroids_pca <- predict(pca_res, newdata = scratch_centroids)
centroids_df <- data.frame(centroids_pca[,1:2])
p_centroids <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched)) +
geom_point(alpha = 0.4) +
geom_point(data = centroids_df, aes(x = PC1, y = PC2),
shape = 8, color = "black", size = 4) +
labs(title = "Scratch K-Means Centroids (PCA)") +
theme_minimal()
# ==============================
# 7. Confusion tables
# ==============================
cat("Scratch K-means vs true species:\n")
print(table(Predicted = scratch_matched, Actual = iris$Species))
cat("\nBuilt-in K-means vs true species:\n")
print(table(Predicted = builtin_matched, Actual = iris$Species))
# ==============================
# 8. Display plots together
# ==============================
grid.arrange(elbow_plot, p_scratch, p_builtin, p_centroids, ncol = 2)
# ==============================
# K-MEANS COMPARISON SCRIPT
# ==============================
# Load scratch implementation
source("kmeans_helpers.R")
source("kmeans_main.R")
# Load required libraries
library(ggplot2)
library(gridExtra) # for arranging multiple plots
library(clue)      # for Hungarian algorithm
# ==============================
# Prepare data
# ==============================
data(iris)
X <- as.matrix(iris[, 1:4])
colnames(X) <- colnames(iris[, 1:4])
scaled_data <- scale(X)
colnames(scaled_data) <- colnames(X)
# ==============================
# 1. Elbow method (built-in kmeans)
# ==============================
set.seed(42)
wss <- sapply(1:10, function(k){
kmeans(scaled_data, k, nstart = 25)$tot.withinss
})
elbow_plot <- ggplot(data.frame(k = 1:10, WSS = wss), aes(x = k, y = WSS)) +
geom_point() + geom_line() +
labs(title = "Elbow Method for Iris (Built-in K-means)",
x = "Number of clusters k",
y = "Total Within-Cluster Sum of Squares") +
theme_minimal()
# ==============================
# 2. Built-in K-means (k=3)
# ==============================
k_chosen <- 3
set.seed(42)
km_builtin <- kmeans(scaled_data, centers = k_chosen, nstart = 25)
builtin_clusters <- km_builtin$cluster
# ==============================
# 3. Scratch K-means (K-means++ initialization)
# ==============================
history_scratch <- kmeans_iterations(scaled_data, k = k_chosen, max_iter = 100, use_kmeanspp = TRUE)
final_iter <- tail(history_scratch, 1)[[1]]  # last iteration
scratch_clusters <- final_iter$clusters
scratch_centroids <- final_iter$centroids
# ==============================
# 4. Cluster-to-species mapping (Hungarian algorithm)
# ==============================
map_clusters_to_species <- function(clusters, species) {
clusters <- as.numeric(clusters)
species_num <- as.numeric(factor(species))
k <- length(unique(clusters))
# Contingency table
tab <- table(clusters, species_num)
# Optimal assignment
assignment <- solve_LSAP(tab, maximum = TRUE)
# Remap clusters
new_clusters <- clusters
for (i in 1:k) {
new_clusters[clusters == i] <- assignment[i]
}
# Convert back to factor with species names
factor(new_clusters, labels = levels(factor(species)))
}
scratch_matched <- map_clusters_to_species(scratch_clusters, iris$Species)
builtin_matched <- map_clusters_to_species(builtin_clusters, iris$Species)
# ==============================
# 5. PCA for visualization
# ==============================
pca_res <- prcomp(scaled_data, center = TRUE, scale. = TRUE)
pca_data <- data.frame(pca_res$x[,1:2],
ScratchCluster = factor(scratch_clusters),
BuiltinCluster = factor(builtin_clusters),
ScratchMatched = scratch_matched,
BuiltinMatched = builtin_matched,
Species = iris$Species)
# ==============================
# 6. PCA plots
# ==============================
# Scratch K-means
p_scratch <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Scratch K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Built-in K-means
p_builtin <- ggplot(pca_data, aes(x = PC1, y = PC2, color = BuiltinMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Built-in K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Scratch K-means centroids overlay
centroids_pca <- predict(pca_res, newdata = scratch_centroids)
centroids_df <- data.frame(centroids_pca[,1:2])
p_centroids <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched)) +
geom_point(alpha = 0.4) +
geom_point(data = centroids_df, aes(x = PC1, y = PC2),
shape = 8, color = "black", size = 4) +
labs(title = "Scratch K-Means Centroids (PCA)") +
theme_minimal()
# ==============================
# 7. Confusion tables
# ==============================
cat("Scratch K-means vs true species:\n")
print(table(Predicted = scratch_matched, Actual = iris$Species))
cat("\nBuilt-in K-means vs true species:\n")
print(table(Predicted = builtin_matched, Actual = iris$Species))
# ==============================
# 8. Display plots together
# ==============================
grid.arrange(elbow_plot, p_scratch, p_builtin, p_centroids, ncol = 2)
# ==============================
# K-MEANS COMPARISON SCRIPT
# ==============================
# Load scratch implementation
source("kmeans_helpers.R")
source("kmeans_main.R")
# Load required libraries
library(ggplot2)
library(gridExtra) # for arranging multiple plots
library(clue)      # for Hungarian algorithm
# ==============================
# Prepare data
# ==============================
data(iris)
X <- as.matrix(iris[, 1:4])
colnames(X) <- colnames(iris[, 1:4])
scaled_data <- scale(X)
colnames(scaled_data) <- colnames(X)
# ==============================
# 1. Elbow method (built-in kmeans)
# ==============================
set.seed(42)
wss <- sapply(1:10, function(k){
kmeans(scaled_data, k, nstart = 25)$tot.withinss
})
elbow_plot <- ggplot(data.frame(k = 1:10, WSS = wss), aes(x = k, y = WSS)) +
geom_point() + geom_line() +
labs(title = "Elbow Method for Iris (Built-in K-means)",
x = "Number of clusters k",
y = "Total Within-Cluster Sum of Squares") +
theme_minimal()
# ==============================
# 2. Built-in K-means (k=3)
# ==============================
k_chosen <- 3
set.seed(42)
km_builtin <- kmeans(scaled_data, centers = k_chosen, nstart = 25)
builtin_clusters <- km_builtin$cluster
# ==============================
# 3. Scratch K-means (K-means++ initialization)
# ==============================
history_scratch <- kmeans_iterations(scaled_data, k = k_chosen, max_iter = 100, use_kmeanspp = TRUE)
final_iter <- tail(history_scratch, 1)[[1]]  # last iteration
scratch_clusters <- final_iter$clusters
scratch_centroids <- final_iter$centroids
# ==============================
# 4. Cluster-to-species mapping (Hungarian algorithm)
# ==============================
map_clusters_to_species <- function(clusters, species) {
clusters <- as.numeric(clusters)
species_num <- as.numeric(factor(species))
k <- length(unique(clusters))
# Contingency table
tab <- table(clusters, species_num)
# Optimal assignment
assignment <- solve_LSAP(tab, maximum = TRUE)
# Remap clusters
new_clusters <- clusters
for (i in 1:k) {
new_clusters[clusters == i] <- assignment[i]
}
# Convert back to factor with species names
factor(new_clusters, labels = levels(factor(species)))
}
scratch_matched <- map_clusters_to_species(scratch_clusters, iris$Species)
builtin_matched <- map_clusters_to_species(builtin_clusters, iris$Species)
# ==============================
# 5. PCA for visualization
# ==============================
pca_res <- prcomp(scaled_data, center = TRUE, scale. = TRUE)
pca_data <- data.frame(pca_res$x[,1:2],
ScratchCluster = factor(scratch_clusters),
BuiltinCluster = factor(builtin_clusters),
ScratchMatched = scratch_matched,
BuiltinMatched = builtin_matched,
Species = iris$Species)
# ==============================
# 6. PCA plots
# ==============================
# Scratch K-means
p_scratch <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Scratch K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Built-in K-means
p_builtin <- ggplot(pca_data, aes(x = PC1, y = PC2, color = BuiltinMatched, shape = Species)) +
geom_point(size = 3, alpha = 0.7) +
labs(title = "Built-in K-Means (Matched Clusters)", x = "PC1", y = "PC2") +
theme_minimal()
# Scratch K-means centroids overlay
centroids_pca <- predict(pca_res, newdata = scratch_centroids)
centroids_df <- data.frame(centroids_pca[,1:2])
p_centroids <- ggplot(pca_data, aes(x = PC1, y = PC2, color = ScratchMatched)) +
geom_point(alpha = 0.4) +
geom_point(data = centroids_df, aes(x = PC1, y = PC2),
shape = 8, color = "black", size = 4) +
labs(title = "Scratch K-Means Centroids (PCA)") +
theme_minimal()
# ==============================
# 7. Confusion tables
# ==============================
cat("Scratch K-means vs true species:\n")
print(table(Predicted = scratch_matched, Actual = iris$Species))
cat("\nBuilt-in K-means vs true species:\n")
print(table(Predicted = builtin_matched, Actual = iris$Species))
# ==============================
# 8. Display plots together
# ==============================
grid.arrange(elbow_plot, p_scratch, p_builtin, p_centroids, ncol = 2)
